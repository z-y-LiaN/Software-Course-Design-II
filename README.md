# 1. 词法分析器

## 1.1 基本原理

- **正规文法**

  - 也称**3型**文法 G=(VN,VT,S,P)
  - 其中P中的每一条规则都有下述形式：`A->aB或A->a`，其中A和B是非终结符，a是终结符的闭包

- **不确定的有穷自动机NFA**

  > 一个不确定的 有穷自动机M 是一个五元组：![](http://latex.codecogs.com/gif.latex?\\M=(K,\sum,f,S,Z))

  - K：有穷集，每个元素称为一个**状态**
  - Σ：有穷字母表，每一个元素称为一个**输入符号**

  - f：一个映射
  - S ⊆ K：非空初态集（对于**DFA，初态唯一**）
  - Z ⊆ K：终态集

- **字符串t能被DFA所接收**

  - 对于$\sum^{*}$中的任何符号串t，若存在一条从初态节点到某一终态节点的道路，且这条道路的所有弧的标记符连接成的符号等于t，则称t可被这个DFA所接收（识别），若DFA的初态节点同时又是终态节点，则空字($\epsilon$)可为DFA所接收

## 1.2 设计思路

- 最先开始先以课本上给出的简单构词规则进行编写代码，进行调试，然后逐步扩充和完善构词规则，进行编码和调试。严格按照词法分析流程，根据规定的正规文法，先**构建NFA**，再利用子集法**确定为DFA**，分模块逐步完成主要函数。最后再通过DFA，读入测试程序进行扫描进行词法分析，得到**输出的token序列**或者错误信息。生成 token 列表（三元组：所在行号，类别，token 内容）。由于算法所用数据结构和C++中许多已有数据结构概念相符，因此可考虑用C++代码编写，充分利用C++中的STL库，十分方便算法的实现。

## 1.3 文件结构

| 路径                        | 文件说明                                               |
| --------------------------- | ------------------------------------------------------ |
| Lexical\TXT\GRAMMAR.txt     | 存放构词规则（正规文法）                               |
| Lexical\TXT\INCHAR.txt      | 存放终结符                                             |
| Lexical\TXT\KEYWORDS.txt    | 存放关键字                                             |
| Lexical\TXT\LIMITER.txt     | 存放界符(限定符）                                      |
| Lexical\TXT\OPERATOR.txt    | 存放操作符                                             |
| Lexical\TXT\ROW.txt         | 存放源程序中每一行的token数，便于语法分析器的报错提示  |
| Lexical\TXT\SOURCE.txt      | 存放源程序代码                                         |
| Lexical\TXT\TOKEN_TRIAD.txt | 存放输出的token序列（三元组）                          |
| Lexical\TXT\TOKEN.txt       | 存放输出的token序列（二元组）                          |
| Lexical\TXT\WRONG.txt       | 存放语法分析器的报错信息，同时便于语法分析器的分析判断 |
| Lexical\lexical.cpp         | 函数实现                                               |
| Lexical\path.h              | 文件路径定义的头文件                                   |
| Lexical\lexical.h           | 函数和变量声明的头文件                                 |
| Lexical\main.cpp            | 主函数                                                 |


## 1.4 实例分析

- 输入正确源程序，词法分析成功，无误。

  ![](https://i.bmp.ovh/imgs/2022/05/04/e3ae273befe2d076.png)

- 修改源程序，检查，能够报出错误信息，指明出错位置

  ![](https://i.bmp.ovh/imgs/2022/05/04/ffbf88b2345bd018.png)



# 2. LR(1)语法分析器

## 2.1 基本原理

- **LR分析法**
  - 根据**状态栈**，和**向右顺序查看**输入串的$k(k≥0)$ 个符号，就可以唯一地确定分析器的动作**是移进还是归约**和用哪个产生式归约，因而能就确定唯一的句柄。
  - LR分析法的归约过程是规范推导的逆过程，所以LR分析过程是一种规范归约的过程
- **LR分析器**
  - 总控程序
  - 分析表：Action-Goto表
  - 分析栈：状态栈、符号栈；
    - 分析器的动作由栈顶状态和当前输入符号来确定
      - 移进：当$S_{j}=GOTO[S_{i},a]$ 成立，将$S_{j}$ 移入到状态栈，将$a$ 移入符号栈
      - 归约：当栈顶形成句柄$\beta$ ，用$\beta$ 归约为相应的非终结符
      - 接受：归约到文法符号栈中只剩下开始符号S，并且输入符号串结束，分析成功
      - 报错：当遇到状态栈顶为某一状态下出现不该遇到的文法符号时报错，无法接受该句子
- **几种LR分析法的区别**
  - **LR(1)**
    - 分析过程不需要向右查看输入符号
    - 不存在**移进-归约** 和 **归约-归约** 冲突，即 R(0)文法分析**不能解决这两种冲突**，所以适用范围最小
  - **SLR(1)**
    - 简单的LR(1)，存在**多余（无效）归约**的情况
    - 不存在归约-归约冲突，**有可能存在移进-归约冲突**，但是如果可以用 follow集解决则是 SLR文法。换句话说，SLR文法分析过程可以解决归约-归约冲突，但是**不一定能解决移进-归约冲突**。用 follow集来处理即出现移进-归约冲突的两条产生式，如果其 follow集相交为空则为 SLR文法，反之不是。
  - **LR(1)**
    - 因为 LR(1)文法的范围比较大，所以文法几乎都是 LR(1)的
- **项目集中的项目种类**
  - 移进项目、待约项目、归约项目、接受项

## 2.2 设计思路

​	读入二型文法产生式文档，识别出所有终结符和非终结符，求相应的First集，构建初始项目集，求其闭包，进行状态转移，得到项目集族，构建Action-Goto表，最后构造分析表。编码过程中，严格分模块进行，每完成一个模块就进行一个模块的测试和校正。大量使用STL极大的简便了繁琐的编码。

## 2.3 文件结构

| 路径                       | 文件说明                |
| -------------------------- | ----------------------- |
| Parser\TXT\ACTION_GOTO.txt | 存放产生的Action-Goto表 |
| Parser\TXT\ANALYSIS.TXT    | 存放分析表              |
| Parser\TXT\GRAMMAR.txt     | 存放文法表              |
| Parser\TXT\ITEMSET.txt     | 存放产生的项目集        |
| Parser\main.cpp            | 主函数                  |
| Parser\parser.cpp          | 函数实现                |
| Parser\parser.h            | 函数和变量声明的头文件  |
| Parser\path.h              | 文件路径定义的头文件    |


## 2.4 实例分析

- 输入正确源程序，语法分析成功，无误。

  ![](https://i.bmp.ovh/imgs/2022/05/04/02c1fa10669f0a07.png)

- 修改源程序，检查，能够报出错误信息，指明出错位置

  ![](https://i.bmp.ovh/imgs/2022/05/04/b27acca327a65bb3.png)

  

# 3. 运行环境说明

- 操作系统：Windows 10

- 运行环境：Visual Studio Code

- 说明：编译链接Lexical或者Parser中的各个.cpp文件，然后运行main.cpp即可，Visual Studio Code环境下推荐CodeRunner插件一键运行；若更改源程序进行语法分析器的测试，请先运行词法分析器得到相应的token，再进行语法分析

  